{"componentChunkName":"component---src-templates-blog-post-js","path":"/cypress/cypress_16022022/","result":{"data":{"site":{"siteMetadata":{"title":"Kontrolqa","author":"kostyrko","siteUrl":"https://kostyrko.github.io/kontrolqa","comment":{"disqusShortName":"","utterances":"kostyrko/kontrolqa"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"13ed7cb1-e397-548c-afd2-49459ea8f35b","excerpt":"cypress Page objects Page object pattern - główne założenia: wprowadzenie modułowości w testach -> skupienie logiki testu w jednym miejscu a w innym stworzenie samego testu.\n👉 pozwala na ograniczenie używania selektorów w testach (✌️ pozytywnie wpływa na czytelność kodu…","html":"<p><img src=\"https://www.cypress.io/static/cypress-io-logo-social-share-8fb8a1db3cdc0b289fad927694ecb415.png\" alt=\"cypress\"></p>\n<h3 id=\"page-objects\" style=\"position:relative;\"><a href=\"#page-objects\" aria-label=\"page objects permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Page objects</h3>\n<p><strong>Page object pattern</strong> - główne założenia: wprowadzenie modułowości w testach -> skupienie logiki testu w jednym miejscu a w innym stworzenie samego testu.\n👉 pozwala na ograniczenie używania selektorów w testach (✌️ pozytywnie wpływa na czytelność kodu)\n🤌 niewielkie zmiany dokonane w testowanej aplikacji powinny mieć wpływ na zmianę Page Objectu, unikając zmian w kodzie testu (🤜 testy prostsze w utrzymaniu).</p>\n<p>Podsumowując</p>\n<ul>\n<li>wprowadza dodatkową abstrakcję dla interakcji z UI</li>\n<li>zawiera szczegóły struktury UI strony oraz (części) jej funkcjonalności w jednej klasie/obiekcie</li>\n</ul>\n<p>Page objecty przechowujemy w dedykowanym folderze (np. pageObjects) znajdującym się po za folderem ‘integrations’ jak reszta plików z kodem testowym.</p>\n<h4 id=\"1-page-object-oparty-na-klasie\" style=\"position:relative;\"><a href=\"#1-page-object-oparty-na-klasie\" aria-label=\"1 page object oparty na klasie permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Page object oparty na klasie</h4>\n<p>Przyjęte jest, że Page Objecty tworzone są na podstawie klasy / w przypadku Cypressa nie jest to jedank konieczne (o czym mowa poniżej).</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export class CreditsPgObj {\n    getCreditsCheckbox() {\n        cy.get('[data-cy=\"creditBox\"]')\n    }\n\n    static getCreditsInfo() {\n        cy.get('[data-cy=\"creditsInfo\"]')\n    }\n\n    [...]\n}\n\nexport class ThanksCreditsPg {\n    getProviderName() {\n        return cy.get('[data-cy=\"providerName\"]')\n    }\n\n    static getTransactionId() {\n        return cy.get('[data-cy=\"transactionId\"]')\n    }\n}</code></pre></div>\n<p><strong>Zastosowanie</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/// &lt;reference types=\"cypress\" />\nimport { viewports } from '../../support/main'\n// zaimportowanie klasy obiektu\nimport { CreditsPage } from '../../support/credits'\n\nviewports.forEach(viewport => {\ndescribe(`Bonus credits management - (${viewport})`, () => {\n    // stworzenie nowej instancji klasy page obiektu\n    const creditsPage = new CreditsPgObj()\n    beforeEach(() => {\n        cy.viewport(viewport)\n        cy.visit('').wait('@xyz').wait('@yz').wait('@zx')\n    })\n\n    it('Bonus credits offer should be displayed')\n    () => {\n        CreditsPage.getLimitedTimeOffer().should('be.visible')\n        CreditsPage.getCreditsProductBonus().should('be.visible')\n        CreditsPage.getCreditsProductBonus().first().should('include.text', '100 Credits')\n    },\n    )\n})\n})</code></pre></div>\n<h4 id=\"2-page-object-oparty-na-obiekcie\" style=\"position:relative;\"><a href=\"#2-page-object-oparty-na-obiekcie\" aria-label=\"2 page object oparty na obiekcie permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Page object oparty na obiekcie</h4>\n<p>W przypadku Cypressa, nie ma potrzeby tworzenia Page Objectów jako klas, a także tworzenia ich instancji ponieważ te nie wymagaj  prototypów innych klas i same nimi być nie muszą - zamiast tego Page Objecty mogą składać się nawet z pojedynczych funkcji lub dla porządku mogą one być zebrane w ramach obiektu.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export const menuPage = {\n    menuOpen: () => {\n        cy.get(menuSelectors.openMenuBtn).click();\n    },\n    menuClose: () => {\n        cy.get(menuSelectors.closMenuBtn).click().should('not.be.visible');\n    },\n    logOut: () => {\n            cy.get(menuSelectors.menuItems.logout).click();\n            cy.url().should('include', '/login');\n        },\n};</code></pre></div>\n<h4 id=\"3-sposób-na-podział-logiki-w-page-objecty-model-pom\" style=\"position:relative;\"><a href=\"#3-spos%C3%B3b-na-podzia%C5%82-logiki-w-page-objecty-model-pom\" aria-label=\"3 sposób na podział logiki w page objecty model pom permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Sposób na podział logiki w Page Objecty Model (POM)</h4>\n<p> Swego czasu tutaj: <a href=\"https://kostyrko.github.io/zfrontu/testing-good-practices.html\">Dobre zasady testowania</a> pisałem, że dobry układ testu tj 3xA (Arrange/aranżacja, Act/działanie, Assert/sprawdzanie) - jak to się odnosi do tzw POM? Ja to rozumiem w sposób następujący - PageObject jest odpowiedzialny za interakcję ze stroną (przechowuje akcje, które są powtarzane w tekście) - jednak sama asercja (sprawdzenie poprawności wykonania się akcji) powinna znajdować się wewnątrz testu. Przygotowanie testu odbywać się może w różnych miejscach i na różne sposoby (pomijając przygotowanie środowiska-> cy.visit/cy.intercept czy localStorage, które mogą się znaleźć np. w beforeEach) ale skupiać w sobie będzie zebranie selektorów (w osobnej klasie bądź obiekcie), które następnie będą wykorzystane zarówno w ramach testu jak i w Page Object.</p>\n<p>Scenariusz testowy w kontekście testowania aplikacji blogowej może przedstawiać się w sposób następujący: logujemy się, przechodzimy do sekcji z nowymi artykułami, tworzymy treść nowego artykuły, postujemy go - a następnie sprawdzamy czy artykuł został dodany/opublikowany.</p>\n<p><strong>Często spotykane podejście (podejście liniowe)</strong> => 1. Zebranie selektorów w obiekcie (w którym przechowywany jest PageObject), 2. wykorzystanie PageObjectu min. do cy.get() + funkcjonalność 3. wykorzystanie w tekście getterów z PageObjectu do tworzenia asercji.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const SELECTORS = {\n    ACCEPT_BUTTON: \"#accept-cookies\",\n    REJECT_BUTTON: \"#reject-cookies\",\n    LOCALSTORAGE_DISABLED_WARNING: \"#localstorage-disabled-warning\",\n};</code></pre></div>\n<p><strong>Alternatywne podejście: rozbicie logiki na 3 klasy/obiekty/części (podejście funkcjonalne)</strong> => 1. przechowuje gettery = cy.get() + selektory 2. akcje/funkcjonalność (wykorzystuje logikę 1.) 3. test (tu wykorzystywana jest logika z 1. 2.)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    const getSubmitSearchButton = () => cy.get('[cypress-id]=submit-search');</code></pre></div>\n<p>Powyżej przedstawiony jest przypadek pojedynczej funkcji, ale te (jak zauważyłem powyżej mogą być również zebrane w obiektach)</p>\n<p>wykorzystując <a href=\"https://anton-kravchenko.github.io/cypress-selectors/\">cypress-selectors</a> zapis może wyglądać następująco:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    @ByType('input') static searchInput: Selector;</code></pre></div>\n<p>Przykładowe zastosowanie</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">it('change language between different languages', () => {\n    Object.keys(i18nextLngs).forEach((language) => {\n        cy.wrap(footerPage.changeLanguage(language)).then(() =>\n            expect(localStorage.getItem('i18nextLng')).to.eq(i18nextLngs[language])\n        );\n    });\n});</code></pre></div>\n<p>gdzie footerPage.js (w tym przypadku selektory przetrzymywane są w osobnym pliku oraz obiekcie ‘footerSelectors’ choć nie w postaci getterów a jedynie selektorów - zatem realizowane jest podejście liniowe):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { footerSelectors } from '../support/selectors/footerSelectors';\n\nconst i18nextLngs = {\n    en: 'en',\n    pl: 'pl',\n};\n\nexport const footerPage = {\n    changeLanguage: (language) => {\n        cy.get(footerSelectors.languageBtn).click({ waitForAnimations: false });\n        cy.get(footerSelectors.languageOption)\n        .contains(language[0].toUpperCase() + language.substring(1))\n        .click({ waitForAnimations: false });\n    },\n};</code></pre></div>\n<hr>\n<p>Źródła:</p>\n<p><a href=\"https://medium.com/geekculture/using-pageobject-pattern-with-cypress-6d9907850522\">Using PageObject pattern with Cypress</a> => <a href=\"https://github.com/anton-kravchenko/cypress-page-object-example\">anton-kravchenko/cypress-page-object-example</a> => <a href=\"https://anton-kravchenko.github.io/cypress-selectors/\">cypress-selectors</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=bC9bGHDgpQk&#x26;list=PLYDwWPRvXB8-8LG2hZv25HO6C3w_vezZb&#x26;index=15\">CYPRESS Page Object Model EXAMPLE | POM in CYPRESS</a></p>\n<p><a href=\"https://www.cypress.io/blog/2019/01/03/stop-using-page-objects-and-start-using-app-actions/\">Stop using Page Objects and Start using App Actions</a></p>","frontmatter":{"title":"Cypress - Page Objects","date":" 16/02/2022"}}},"pageContext":{"slug":"/cypress/cypress_16022022/","previous":null,"next":null}}}